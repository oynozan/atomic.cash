pragma cashscript ^0.12.0;

contract Atomic(bytes20 poolOwnerPkh) {
    function swapExactInput() {
        bytes inputToken = tx.inputs[this.activeInputIndex].tokenCategory;
        bytes outputToken = tx.outputs[this.activeInputIndex].tokenCategory;
        require(inputToken == outputToken);
        
        require(tx.version == 2);
        
        bytes inputBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
        bytes outputBytecode = tx.outputs[this.activeInputIndex].lockingBytecode;
        require(inputBytecode == outputBytecode);
        
        int targetK = tx.inputs[this.activeInputIndex].value 
                    * tx.inputs[this.activeInputIndex].tokenAmount;
        
        int tradeValue = abs(
            tx.inputs[this.activeInputIndex].value 
            - tx.outputs[this.activeInputIndex].value
        );
        int fee = (tradeValue * 3) / 1000;
        
        int effectiveOutputK = (tx.outputs[this.activeInputIndex].value - fee) 
                             * tx.outputs[this.activeInputIndex].tokenAmount;

        require(effectiveOutputK >= targetK);
    }

    function swapExactOutput() {
        bytes inputToken = tx.inputs[this.activeInputIndex].tokenCategory;
        bytes outputToken = tx.outputs[this.activeInputIndex].tokenCategory;
        require(inputToken == outputToken);
        require(tx.version == 2);
        
        bytes inputBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
        bytes outputBytecode = tx.outputs[this.activeInputIndex].lockingBytecode;
        require(inputBytecode == outputBytecode);
        
        int targetK = tx.inputs[this.activeInputIndex].value 
                    * tx.inputs[this.activeInputIndex].tokenAmount;
        
        int tradeValue = abs(
            tx.inputs[this.activeInputIndex].value 
            - tx.outputs[this.activeInputIndex].value
        );
        int fee = (tradeValue * 3) / 1000;
        
        int effectiveOutputK = (tx.outputs[this.activeInputIndex].value - fee) 
                             * tx.outputs[this.activeInputIndex].tokenAmount;
        
        require(effectiveOutputK >= targetK);
    }

    function addLiquidity(pubkey poolOwnerPk, sig poolOwnerSig) {
        
        require(hash160(poolOwnerPk) == poolOwnerPkh);
        require(checkSig(poolOwnerSig, poolOwnerPk));
        
        bytes inputToken = tx.inputs[this.activeInputIndex].tokenCategory;
        bytes outputToken = tx.outputs[this.activeInputIndex].tokenCategory;
        require(inputToken == outputToken);
        
        bytes inputBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
        bytes outputBytecode = tx.outputs[this.activeInputIndex].lockingBytecode;
        require(inputBytecode == outputBytecode);
    }

    function removeLiquidity(pubkey poolOwnerPk, sig poolOwnerSig) {
        
        require(hash160(poolOwnerPk) == poolOwnerPkh);
        require(checkSig(poolOwnerSig, poolOwnerPk));
        
        // Enforce that the pool UTXO continues to exist after removal and that
        // at least ~0.01% of the tokens stay in the pool so the UI max (99.99%)
        // matches the on-chain rule. We add a small tolerance ( + 9999 ) to
        // account for integer rounding when the UI computes percentage-based
        // withdrawals.
        int currentTokens = tx.inputs[this.activeInputIndex].tokenAmount;
        int remainingTokens = tx.outputs[this.activeInputIndex].tokenAmount;
        require(remainingTokens > 0);
        // remainingTokens / currentTokens >= ~0.0001
        // => remainingTokens * 10000 (+ tolerance) >= currentTokens
        require(remainingTokens * 10000 + 9999 >= currentTokens);
        
        bytes inputToken = tx.inputs[this.activeInputIndex].tokenCategory;
        bytes outputToken = tx.outputs[this.activeInputIndex].tokenCategory;
        require(inputToken == outputToken);
        
        bytes inputBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
        bytes outputBytecode = tx.outputs[this.activeInputIndex].lockingBytecode;
        require(inputBytecode == outputBytecode);
    }
}
